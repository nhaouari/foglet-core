<!doctype html>
<html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{&quot;stats&quot;:{&quot;suites&quot;:13,&quot;tests&quot;:28,&quot;passes&quot;:28,&quot;pending&quot;:0,&quot;failures&quot;:0,&quot;start&quot;:&quot;2018-06-26T14:34:56.005Z&quot;,&quot;end&quot;:&quot;2018-06-26T14:35:38.591Z&quot;,&quot;duration&quot;:42586,&quot;testsRegistered&quot;:28,&quot;passPercent&quot;:100,&quot;pendingPercent&quot;:0,&quot;other&quot;:0,&quot;hasOther&quot;:false,&quot;skipped&quot;:0,&quot;hasSkipped&quot;:false,&quot;passPercentClass&quot;:&quot;success&quot;,&quot;pendingPercentClass&quot;:&quot;danger&quot;},&quot;suites&quot;:{&quot;uuid&quot;:&quot;dba479e9-7992-461d-af68-0535e1b5556d&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;1bf54ab4-b2e2-41a8-934c-40dde6cb87d0&quot;,&quot;title&quot;:&quot;Foglet High-level communication&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-communication-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-communication-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should send messages to a neighbour using unicast&quot;,&quot;fullTitle&quot;:&quot;Foglet High-level communication should send messages to a neighbour using unicast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2036,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf2.onUnicast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  assert.equal(message, &#x27;hello&#x27;)\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    console.log(peers)\n    assert.equal(peers.length, 1)\n    console.log(peers)\n    for (let i = 0; i &lt; peers.length; i++) {\n      f1.sendUnicast(peers[i], &#x27;hello&#x27;)\n    }\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;f75fecfb-8183-4716-bb10-706ff6f349e8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should send messages to several neighbours using multicast&quot;,&quot;fullTitle&quot;:&quot;Foglet High-level communication should send messages to several neighbours using multicast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2014,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet wanted = 0\nlet received = 0\nfunction receive (id, message) {\n  received++\n  assert.equal(id, f1.outViewID)\n  assert.equal(message, &#x27;hello&#x27;)\n  if (received &gt;= wanted) {\n    utils.clearFoglets(foglets).then(() =&gt; done())\n  }\n}\nf2.onUnicast(receive)\nf3.onUnicast(receive)\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(() =&gt; {\n    const peers = f1.getNeighbours()\n    wanted = peers.length\n    f1.sendMulticast(peers, &#x27;hello&#x27;)\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;46733e86-a162-45c8-91e7-fee3f7f1f121&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should send messages to all peers using broadcast in a network with 2 peers&quot;,&quot;fullTitle&quot;:&quot;Foglet High-level communication should send messages to all peers using broadcast in a network with 2 peers&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2012,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nlet neighbourID = null\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf2.onBroadcast((id, data) =&gt; {\n  assert.equal(id, neighbourID)\n  assert.equal(data, &#x27;hello&#x27;)\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  neighbourID = f1.outViewID\n  setTimeout(function () {\n    f1.sendBroadcast(&#x27;hello&#x27;)\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;8e7b1fea-52e2-4966-a347-715a7d1300d8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should simply send messages to all peers using broadcast in a 3 peers network&quot;,&quot;fullTitle&quot;:&quot;Foglet High-level communication should simply send messages to all peers using broadcast in a 3 peers network&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2014,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet cptA = 0\nlet cptB = 0\nconst results = [ &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27; ]\nconst totalResult = 8\nconst check = utils.doneAfter(totalResult, () =&gt; {\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  f2.onBroadcast((id, message) =&gt; {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptA])\n    cptA++\n    check()\n  })\n  f3.onBroadcast((id, message) =&gt; {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptB])\n    cptB++\n    check()\n  })\n  setTimeout(() =&gt; {\n    f1.sendBroadcast(&#x27;1&#x27;)\n    f1.sendBroadcast(&#x27;2&#x27;)\n    f1.sendBroadcast(&#x27;3&#x27;)\n    f1.sendBroadcast(&#x27;4&#x27;)\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;d79cd9d7-9d0e-4f38-882f-791d9664c54f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should receive broadcasted classically ordered messages in a 3 peers network (1-2-3-4)&quot;,&quot;fullTitle&quot;:&quot;Foglet High-level communication should receive broadcasted classically ordered messages in a 3 peers network (1-2-3-4)&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2016,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet cptA = 0\nlet cptB = 0\nconst results = [ &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27; ]\nconst totalResult = 8\nconst check = utils.doneAfter(totalResult, () =&gt; {\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  f2.onBroadcast((id, message) =&gt; {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptA])\n    cptA++\n    check()\n  })\n  f3.onBroadcast((id, message) =&gt; {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptB])\n    cptB++\n    check()\n  })\n  setTimeout(() =&gt; {\n    const id1 = f1.overlay().communication.sendBroadcast(&#x27;1&#x27;)\n    const id2 = f1.overlay().communication.sendBroadcast(&#x27;2&#x27;, null, id1)\n    const id3 = f1.overlay().communication.sendBroadcast(&#x27;3&#x27;, null, id2)\n    f1.overlay().communication.sendBroadcast(&#x27;4&#x27;, null, id3)\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;62408cdb-861c-40a2-bec3-db1f37256eaf&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should receive broadcasted weirdly ordered messages in a 3 peers network (1-3-2-4)&quot;,&quot;fullTitle&quot;:&quot;Foglet High-level communication should receive broadcasted weirdly ordered messages in a 3 peers network (1-3-2-4)&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4023,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet cptA = 0\nlet cptB = 0\nconst results = [ &#x27;1&#x27;, &#x27;3&#x27;, &#x27;2&#x27;, &#x27;4&#x27; ]\nconst totalResult = 8\nconst check = utils.doneAfter(totalResult, () =&gt; {\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  f2.onBroadcast((id, message) =&gt; {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptA])\n    cptA++\n    check()\n  })\n  f3.onBroadcast((id, message) =&gt; {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptB])\n    cptB++\n    check()\n  })\n  setTimeout(() =&gt; {\n    const id1 = f1.overlay().communication.sendBroadcast(&#x27;1&#x27;)\n    const id2 = f1.overlay().communication.sendBroadcast(&#x27;2&#x27;, null, {e: id1.e, c: 3})\n    setTimeout(() =&gt; {\n      f1.overlay().communication.sendBroadcast(&#x27;3&#x27;, null, id1)\n      f1.overlay().communication.sendBroadcast(&#x27;4&#x27;, null, id2)\n    }, 2000)\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;fcdbc0e2-cf3e-4884-828d-f96ed2baff45&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;f75fecfb-8183-4716-bb10-706ff6f349e8&quot;,&quot;46733e86-a162-45c8-91e7-fee3f7f1f121&quot;,&quot;8e7b1fea-52e2-4966-a347-715a7d1300d8&quot;,&quot;d79cd9d7-9d0e-4f38-882f-791d9664c54f&quot;,&quot;62408cdb-861c-40a2-bec3-db1f37256eaf&quot;,&quot;fcdbc0e2-cf3e-4884-828d-f96ed2baff45&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:14115,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;743788b9-5a65-47bd-a993-a07098e4163a&quot;,&quot;title&quot;:&quot;[FOGLET] Other functions tests&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-main-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-main-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;[FOGLET] getRandomNeighbourId is in getNeighbours&quot;,&quot;fullTitle&quot;:&quot;[FOGLET] Other functions tests [FOGLET] getRandomNeighbourId is in getNeighbours&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  console.log(&#x27;Peers: &#x27;, f1.getNeighbours(), f2.getNeighbours())\n  console.log(&#x27;Random:&#x27;, f1.getRandomNeighbourId(), f2.getRandomNeighbourId())\n  assert.include(f1.getNeighbours(), f1.getRandomNeighbourId())\n  utils.clearFoglets(foglets).then(() =&gt; done())\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;3fd92807-2ed2-4ee7-a228-596bf8f0eeda&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;3fd92807-2ed2-4ee7-a228-596bf8f0eeda&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:10,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;074d7f1a-3682-476f-864b-bddee10ffe60&quot;,&quot;title&quot;:&quot;Middlewares&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-middleware-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-middleware-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should use middleware on broadcast&quot;,&quot;fullTitle&quot;:&quot;Middlewares should use middleware on broadcast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2009,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf1.use(simpleMiddleware)\nf2.use(simpleMiddleware)\nf2.onBroadcast((id, data) =&gt; {\n  assert.equal(data, &#x27;So Long and Thanks for all the Fish&#x27;)\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    f1.sendBroadcast(&#x27;So Long&#x27;)\n  }, 2000)\n})&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;47139e4b-37e6-4530-ae93-12da498ad12d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should use middleware on unicast&quot;,&quot;fullTitle&quot;:&quot;Middlewares should use middleware on unicast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2007,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf1.use(simpleMiddleware)\nf2.use(simpleMiddleware)\nf2.onUnicast((id, message) =&gt; {\n  assert.equal(message, &#x27;So Long and Thanks for all the Fish&#x27;)\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    f1.sendUnicast(peers[0], &#x27;So Long&#x27;)\n  }, 2000)\n})&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;14689cd2-5318-4200-bfb5-80806ba566dd&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;47139e4b-37e6-4530-ae93-12da498ad12d&quot;,&quot;14689cd2-5318-4200-bfb5-80806ba566dd&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4016,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;6e4c575d-0e28-4295-b59c-8e4e79d2664a&quot;,&quot;title&quot;:&quot;Overlays&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-overlay-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-overlay-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should build a simple TMan-based overlay&quot;,&quot;fullTitle&quot;:&quot;Overlays should build a simple TMan-based overlay&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2126,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n    const [ f1, f2 ] = utils.buildFog(Foglet, 2, [\n      {\n        name: &#x27;test-overlay&#x27;,\n        class: TestOverlay,\n        options: {\n          protocol: &#x27;foglet-test-overlay&#x27;,\n          signaling: {\n            room: &#x27;foglet-test-overlay-room&#x27;,\n            address: &#x27;http://localhost:8000/&#x27;\n          }\n        }\n      }\n    ])\n    f1.overlay(&#x27;test-overlay&#x27;).communication.onUnicast((id, msg) =&gt; {\n      assert.equal(msg, &#x27;hello world!&#x27;)\n      console.log(&#x27;Got message from: &#x27;, id, msg)\n      done()\n    })\n    utils.overlayConnect(&#x27;test-overlay&#x27;, 2000, f1, f2)\n      .then(() =&gt; {\n        setTimeout(() =&gt; {\n          const neighbours = f2.overlay(&#x27;test-overlay&#x27;).network.getNeighbours()\n          assert.equal(neighbours.length, 1)\n          f2.overlay(&#x27;test-overlay&#x27;).communication.sendUnicast(neighbours[0], &#x27;hello world!&#x27;)\n        }, 2000)\n      }).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;702e63f1-2480-4d23-b1fe-e23fa96207c7&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should create a internal communication channel correctly&quot;,&quot;fullTitle&quot;:&quot;Overlays should create a internal communication channel correctly&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2036,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n    const [ f1, f2 ] = utils.buildFog(Foglet, 2, [\n      {\n        name: &#x27;test-overlay-communication&#x27;,\n        class: TestOverlay,\n        options: {\n          protocol: &#x27;foglet-test-overlay-communication&#x27;,\n          signaling: {\n            address: &#x27;http://localhost:8000/&#x27;,\n            room: &#x27;foglet-test-overlay-communication-room&#x27;\n          }\n        }\n      }\n    ])\n    f1.overlay(&#x27;test-overlay-communication&#x27;).network.communication.onUnicast((id, msg) =&gt; {\n      assert.equal(msg, &#x27;hello world!&#x27;)\n      console.log(&#x27;Got message from: &#x27;, id, msg)\n      done()\n    })\n    utils.overlayConnect(&#x27;test-overlay-communication&#x27;, 2000, f1, f2)\n      .then(() =&gt; {\n        setTimeout(() =&gt; {\n          const neighbours = f2.overlay(&#x27;test-overlay-communication&#x27;).network.getNeighbours()\n          assert.equal(neighbours.length, 1)\n          f2.overlay(&#x27;test-overlay-communication&#x27;).network.communication.sendUnicast(neighbours[0], &#x27;hello world!&#x27;)\n        }, 2000)\n      }).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;c2f81d84-6c0b-46c0-8592-47d43f008f39&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;702e63f1-2480-4d23-b1fe-e23fa96207c7&quot;,&quot;c2f81d84-6c0b-46c0-8592-47d43f008f39&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4162,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;3a872ee5-bebd-4719-9b3a-ac2264edb201&quot;,&quot;title&quot;:&quot;FogletProtocol&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;d942e510-f7c1-4e49-956c-1cf5f03ec38a&quot;,&quot;title&quot;:&quot;#unicast&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;8bd6ae6b-1d9d-4f24-b1af-08927d5c79fc&quot;,&quot;title&quot;:&quot;#communication&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should receive messages from remote services&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #unicast #communication should receive messages from remote services&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1012,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const expected = &#x27;Hello world!&#x27;\n        const p1 = new UnicastProtocol(f1)\n        const p2 = new UnicastProtocol(f2, (id, msg) =&gt; {\n          assert.equal(msg, expected)\n        }, () =&gt; {\n          utils.clearFoglets(foglets).then(() =&gt; done())\n        })\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], expected)\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;c3cd85d0-6925-4a53-ae4c-7b6c19a06e6d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow peers to reply to service calls&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #unicast #communication should allow peers to reply to service calls&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1009,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastProtocol(f1)\n        const p2 = new UnicastProtocol(f2, (id, msg, reply) =&gt; {\n          reply(msg + &#x27; world!&#x27;)\n        })\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], &#x27;Hello&#x27;)\n              .then(msg =&gt; {\n                assert.equal(msg, &#x27;Hello world!&#x27;)\n                utils.clearFoglets(foglets).then(() =&gt; done())\n              })\n              .catch(() =&gt; {\n                utils.clearFoglets(foglets).then(() =&gt; done())\n              })\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;b33412c0-788f-4b66-885b-6b7a58e9ac12&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow peers to reject service calls&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #unicast #communication should allow peers to reject service calls&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1010,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastProtocol(f1)\n        const p2 = new UnicastProtocol(f2, (id, msg, reply, reject) =&gt; {\n          reject(msg + &#x27; world!&#x27;)\n        })\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], &#x27;Hello&#x27;)\n              .then(msg =&gt; {\n                utils.clearFoglets(foglets).then(() =&gt; done(new Error(&#x27;Message should have rejected but instead got reply with &#x27; + msg)))\n              })\n              .catch(msg =&gt; {\n                assert.equal(msg, &#x27;Hello world!&#x27;)\n                utils.clearFoglets(foglets).then(() =&gt; done())\n              })\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;1031e555-3829-4346-86dc-eca3d9e9a8f4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;c3cd85d0-6925-4a53-ae4c-7b6c19a06e6d&quot;,&quot;b33412c0-788f-4b66-885b-6b7a58e9ac12&quot;,&quot;1031e555-3829-4346-86dc-eca3d9e9a8f4&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:3031,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;4c90c89d-1e4e-46b7-a106-af868a493157&quot;,&quot;title&quot;:&quot;#hooks&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should allow before hooks on send &amp; receive&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #unicast #hooks should allow before hooks on send &amp; receive&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1015,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        UnicastHookProtocol = defineProtocol(&#x27;unicast-protocol-with-hooks&#x27;)`\n          init\n          ${initProtocol}\n          get\n          ${function (service) {\n    service.is.unicast()\n    service.on.receive(function (id, msg) {\n      if (this._callback) this._callback(id, msg)\n      if (this._done) this._done()\n    })\n    service.before.send(function (msg) {\n      return msg + &#x27; and Thanks for&#x27;\n    })\n    service.before.receive(function (msg) {\n      return msg + &#x27; all the Fish&#x27;\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastHookProtocol(f1)\n        const p2 = new UnicastHookProtocol(f2, (id, msg) =&gt; {\n          assert.equal(msg, &#x27;So Long and Thanks for all the Fish&#x27;)\n        }, () =&gt; {\n          utils.clearFoglets(foglets).then(() =&gt; done())\n        })\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], &#x27;So Long&#x27;)\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;47a9542f-9222-46bd-af7a-714dc4ef8f3b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow after hooks on send &amp; receive&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #unicast #hooks should allow after hooks on send &amp; receive&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1007,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        const check = utils.doneAfter(2, () =&gt; {\n          utils.clearFoglets(foglets).then(() =&gt; done())\n        })\n        UnicastHookProtocol = defineProtocol(&#x27;unicast-protocol-with-hooks&#x27;)`\n          get\n          ${function (service) {\n    service.is.unicast()\n    service.on.receive(function () {})\n    service.after.send(function (msg) {\n      assert.equal(msg, &#x27;So Long&#x27;)\n      check()\n    })\n    service.after.receive(function (msg) {\n      assert.equal(msg, &#x27;So Long&#x27;)\n      check()\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastHookProtocol(f1)\n        const p2 = new UnicastHookProtocol(f2)\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], &#x27;So Long&#x27;)\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;5f2fd78b-2d8f-45ba-8378-d38c25188ae2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;47a9542f-9222-46bd-af7a-714dc4ef8f3b&quot;,&quot;5f2fd78b-2d8f-45ba-8378-d38c25188ae2&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:2022,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;3ae0d01d-89e4-4620-9456-7425e1034d6d&quot;,&quot;title&quot;:&quot;#broadcast&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;003312e8-6a83-41e3-b246-09783941cc9d&quot;,&quot;title&quot;:&quot;#communication&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should receive messages from remote services&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #broadcast #communication should receive messages from remote services&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1009,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const expected = &#x27;Hello world!&#x27;\n        const p1 = new BroadcastProtocol(f1)\n        const p2 = new BroadcastProtocol(f2, (id, msg) =&gt; {\n          assert.equal(msg, expected)\n        }, () =&gt; {\n          utils.clearFoglets(foglets).then(() =&gt; done())\n        })\n        utils.pathConnect(foglets, 2000).then(() =&gt; {\n          setTimeout(function () {\n            p1.get(expected)\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;41273cca-b7a4-4960-ae71-e97d18b97ce0&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;41273cca-b7a4-4960-ae71-e97d18b97ce0&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:1009,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;7fca2a3c-eee9-4b7a-8c35-97012c6bf5d1&quot;,&quot;title&quot;:&quot;#hooks&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should allow before hooks on send &amp; receive&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #broadcast #hooks should allow before hooks on send &amp; receive&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1010,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        BroadcastHookProtocol = defineProtocol(&#x27;broadcast-protocol-with-hooks&#x27;)`\n          init\n          ${initProtocol}\n          get\n          ${function (service) {\n    service.is.broadcast()\n    service.on.receive(function (id, msg) {\n      if (this._callback) this._callback(id, msg)\n      if (this._done) this._done()\n    })\n    service.before.send(function (msg) {\n      return msg + &#x27; and Thanks for&#x27;\n    })\n    service.before.receive(function (msg) {\n      return msg + &#x27; all the Fish&#x27;\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new BroadcastHookProtocol(f1)\n        const p2 = new BroadcastHookProtocol(f2, (id, msg) =&gt; {\n          assert.equal(msg, &#x27;So Long and Thanks for all the Fish&#x27;)\n        }, () =&gt; {\n          utils.clearFoglets(foglets).then(() =&gt; done())\n        })\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(&#x27;So Long&#x27;)\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;d9d56266-0e72-4236-95ee-167e5dc0b097&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow after hooks on send &amp; receive&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #broadcast #hooks should allow after hooks on send &amp; receive&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1010,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        const check = utils.doneAfter(2, () =&gt; {\n          utils.clearFoglets(foglets).then(() =&gt; done())\n        })\n        BroadcastHookProtocol = defineProtocol(&#x27;broadcast-protocol-with-hooks&#x27;)`\n          get\n          ${function (service) {\n    service.is.broadcast()\n    service.on.receive(function () {})\n    service.after.send(function (msg) {\n      assert.equal(msg, &#x27;So Long&#x27;)\n      check()\n    })\n    service.after.receive(function (msg) {\n      assert.equal(msg, &#x27;So Long&#x27;)\n      check()\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new BroadcastHookProtocol(f1)\n        const p2 = new BroadcastHookProtocol(f2)\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(&#x27;So Long&#x27;)\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;352cd2e7-eeec-4378-93a0-89963d05e438&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;d9d56266-0e72-4236-95ee-167e5dc0b097&quot;,&quot;352cd2e7-eeec-4378-93a0-89963d05e438&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:2020,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;25c4d079-b515-4a41-b396-56f394007dd5&quot;,&quot;title&quot;:&quot;[SIGNALING] Direct/Signaling connections&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-signaling-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-signaling-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;direct connection, return true when connected&quot;,&quot;fullTitle&quot;:&quot;[SIGNALING] Direct/Signaling connections direct connection, return true when connected&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nutils.pathConnect(foglets, 2000).then((status) =&gt; {\n  assert.isOk(status, &#x27;Status Must be true.&#x27;)\n  utils.clearFoglets(foglets)\n  done()\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;35a9292b-b44d-4cc3-b5bf-7eb7848049bb&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;signaling connection alone, return true when connected&quot;,&quot;fullTitle&quot;:&quot;[SIGNALING] Direct/Signaling connections signaling connection alone, return true when connected&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:10,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 1, [], [{ url: &#x27;stun:global.stun.twilio.com:3478?transport=udp&#x27; }])\nconst f1 = foglets[0]\nf1.share()\nf1.connection().then((status) =&gt; {\n  assert.isOk(status, &#x27;Status Must be true.&#x27;)\n  utils.clearFoglets(foglets)\n  done()\n}).catch(e =&gt; {\n  done(e)\n})&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;b4101840-bfd6-4172-a32f-6745eed330f2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;signaling connection (2 peers network), return true when connected&quot;,&quot;fullTitle&quot;:&quot;[SIGNALING] Direct/Signaling connections signaling connection (2 peers network), return true when connected&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:37,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2, [], [{ url: &#x27;stun:global.stun.twilio.com:3478?transport=udp&#x27; }])\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf1.onUnicast((id, msg) =&gt; {\n  assert.equal(msg, &#x27;ping&#x27;)\n  utils.clearFoglets(foglets)\n  done()\n})\nf1.share()\nf1.connection().then((status) =&gt; {\n  f2.share()\n  assert.isOk(status, &#x27;Status Must be true.&#x27;)\n  f2.connection().then((status) =&gt; {\n    assert.isOk(status, &#x27;Status Must be true.&#x27;)\n    assert.equal(f2.getNeighbours().length, 1)\n    f2.sendUnicast(f2.getNeighbours()[0], &#x27;ping&#x27;)\n  }).catch(done)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;7fce11c4-0b66-426a-84a7-d139075b1ca9&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;35a9292b-b44d-4cc3-b5bf-7eb7848049bb&quot;,&quot;b4101840-bfd6-4172-a32f-6745eed330f2&quot;,&quot;7fce11c4-0b66-426a-84a7-d139075b1ca9&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:54,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;734cc61d-dd64-49e5-993a-497a9d52d372&quot;,&quot;title&quot;:&quot;Foglet streaming communication&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-streams-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-streams-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should stream data to a neighbour using unicast&quot;,&quot;fullTitle&quot;:&quot;Foglet streaming communication should stream data to a neighbour using unicast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2037,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nlet acc = &#x27;&#x27;\nf2.onStreamUnicast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;data&#x27;, data =&gt; { acc += data })\n  message.on(&#x27;end&#x27;, () =&gt; {\n    assert.equal(acc, &#x27;Hello world!Family!&#x27;)\n    utils.clearFoglets(foglets)\n    done()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    const stream = f1.streamUnicast(peers[0])\n    stream.write(&#x27;Hello &#x27;)\n    stream.write(&#x27;world!&#x27;)\n    stream.write(&#x27;Family!&#x27;)\n    stream.end()\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;f430ad4e-7e31-4a25-b1e7-ad6d99abd10c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should stream trailing data to a neighbour using unicast&quot;,&quot;fullTitle&quot;:&quot;Foglet streaming communication should stream trailing data to a neighbour using unicast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2013,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf2.onStreamUnicast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;data&#x27;, () =&gt; null)\n  message.on(&#x27;end&#x27;, () =&gt; {\n    assert.equal(message.trailers.length, 1)\n    assert.equal(message.trailers[0], &#x27;Hello world!Family!&#x27;)\n    utils.clearFoglets(foglets)\n    done()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    const stream = f1.streamUnicast(peers[0])\n    stream.write(&#x27;foo&#x27;)\n    stream.addTrailer(&#x27;Hello world!Family!&#x27;)\n    stream.end()\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;92cbf6b2-80b6-4246-9d05-21a5ccd4a784&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should transmit an error through a stream when using unicast&quot;,&quot;fullTitle&quot;:&quot;Foglet streaming communication should transmit an error through a stream when using unicast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2011,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst check = utils.doneAfter(2, () =&gt; {\n  utils.clearFoglets(foglets)\n  done()\n})\nf2.onStreamUnicast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;error&#x27;, err =&gt; {\n    assert.equal(err, &#x27;Everything goes wrong!&#x27;)\n    check()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    const stream = f1.streamUnicast(peers[0])\n    stream.on(&#x27;error&#x27;, () =&gt; check())\n    stream.destroy(&#x27;Everything goes wrong!&#x27;)\n    stream.end()\n  }, 2000)\n})&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;a6d26960-774a-415b-9bcd-96c268c47e16&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should stream data to all peers using broadcast in a network with 2 peers&quot;,&quot;fullTitle&quot;:&quot;Foglet streaming communication should stream data to all peers using broadcast in a network with 2 peers&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2011,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nlet acc = &#x27;&#x27;\nf2.onStreamBroadcast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;data&#x27;, data =&gt; { acc += data })\n  message.on(&#x27;end&#x27;, () =&gt; {\n    assert.equal(acc, &#x27;Hello world!Family!&#x27;)\n    utils.clearFoglets(foglets)\n    done()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    const stream = f1.streamBroadcast()\n    stream.write(&#x27;Hello &#x27;)\n    stream.write(&#x27;world!&#x27;)\n    stream.write(&#x27;Family!&#x27;)\n    stream.end()\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;f986e411-63e4-400a-b757-59e7d68ac17c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should stream data to all peers using broadcast in a network with 3 peers&quot;,&quot;fullTitle&quot;:&quot;Foglet streaming communication should stream data to all peers using broadcast in a network with 3 peers&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2017,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet accA = &#x27;&#x27;\nlet accB = &#x27;&#x27;\nconst check = utils.doneAfter(2, () =&gt; {\n  utils.clearFoglets(foglets)\n  done()\n})\nf2.onStreamBroadcast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;data&#x27;, data =&gt; { accA += data })\n  message.on(&#x27;end&#x27;, () =&gt; {\n    assert.equal(accA, &#x27;Hello world!Family!&#x27;)\n    check()\n  })\n})\nf3.onStreamBroadcast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;data&#x27;, data =&gt; { accB += data })\n  message.on(&#x27;end&#x27;, () =&gt; {\n    assert.equal(accB, &#x27;Hello world!Family!&#x27;)\n    check()\n  })\n})\nutils.pathConnect(foglets, 1000).then(() =&gt; {\n  setTimeout(function () {\n    const stream = f1.streamBroadcast()\n    stream.write(&#x27;Hello &#x27;)\n    stream.write(&#x27;world!&#x27;)\n    stream.write(&#x27;Family!&#x27;)\n    stream.end()\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;c45e9f63-ee60-47a5-b402-915d9255fddf&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should transmit an error through a stream when using broadcast&quot;,&quot;fullTitle&quot;:&quot;Foglet streaming communication should transmit an error through a stream when using broadcast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2017,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nconst check = utils.doneAfter(3, () =&gt; {\n  utils.clearFoglets(foglets)\n  done()\n})\nf2.onStreamBroadcast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;error&#x27;, err =&gt; {\n    assert.equal(err, &#x27;Everything goes wrong!&#x27;)\n    check()\n  })\n})\nf3.onStreamBroadcast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;error&#x27;, err =&gt; {\n    assert.equal(err, &#x27;Everything goes wrong!&#x27;)\n    check()\n  })\n})\nutils.pathConnect(foglets, 1000).then(() =&gt; {\n  setTimeout(function () {\n    const stream = f1.streamBroadcast()\n    stream.on(&#x27;error&#x27;, () =&gt; check())\n    stream.destroy(&#x27;Everything goes wrong!&#x27;)\n    stream.end()\n  }, 2000)\n})&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;d1cc36b2-7bc3-4cb1-8d11-b20a8f71d1a3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;f430ad4e-7e31-4a25-b1e7-ad6d99abd10c&quot;,&quot;92cbf6b2-80b6-4246-9d05-21a5ccd4a784&quot;,&quot;a6d26960-774a-415b-9bcd-96c268c47e16&quot;,&quot;f986e411-63e4-400a-b757-59e7d68ac17c&quot;,&quot;c45e9f63-ee60-47a5-b402-915d9255fddf&quot;,&quot;d1cc36b2-7bc3-4cb1-8d11-b20a8f71d1a3&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:12106,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:30000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:30000},&quot;copyrightYear&quot;:2018}" data-config="{&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;reportDir&quot;:&quot;./docs/_test-reporter&quot;,&quot;reportTitle&quot;:&quot;foglet-core&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;cdn&quot;:false,&quot;charts&quot;:true,&quot;enableCharts&quot;:true,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showPassed&quot;:true,&quot;showFailed&quot;:true,&quot;showPending&quot;:true,&quot;showSkipped&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;saveJson&quot;:true,&quot;saveHtml&quot;:true,&quot;dev&quot;:false,&quot;assetsDir&quot;:&quot;docs/_test-reporter/assets&quot;,&quot;jsonFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/docs/_test-reporter/mochawesome.json&quot;,&quot;htmlFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/docs/_test-reporter/mochawesome.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>