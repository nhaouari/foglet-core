{
  "stats": {
    "suites": 13,
    "tests": 28,
    "passes": 28,
    "pending": 0,
    "failures": 0,
    "start": "2018-06-26T14:34:56.005Z",
    "end": "2018-06-26T14:35:38.591Z",
    "duration": 42586,
    "testsRegistered": 28,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false,
    "passPercentClass": "success",
    "pendingPercentClass": "danger"
  },
  "suites": {
    "uuid": "dba479e9-7992-461d-af68-0535e1b5556d",
    "title": "",
    "fullFile": "",
    "file": "",
    "beforeHooks": [],
    "afterHooks": [],
    "tests": [],
    "suites": [
      {
        "uuid": "1bf54ab4-b2e2-41a8-934c-40dde6cb87d0",
        "title": "Foglet High-level communication",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-communication-test.js",
        "file": "/tests/foglet-communication-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "should send messages to a neighbour using unicast",
            "fullTitle": "Foglet High-level communication should send messages to a neighbour using unicast",
            "timedOut": false,
            "duration": 2036,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf2.onUnicast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  assert.equal(message, 'hello')\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    console.log(peers)\n    assert.equal(peers.length, 1)\n    console.log(peers)\n    for (let i = 0; i < peers.length; i++) {\n      f1.sendUnicast(peers[i], 'hello')\n    }\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "f75fecfb-8183-4716-bb10-706ff6f349e8",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should send messages to several neighbours using multicast",
            "fullTitle": "Foglet High-level communication should send messages to several neighbours using multicast",
            "timedOut": false,
            "duration": 2014,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet wanted = 0\nlet received = 0\nfunction receive (id, message) {\n  received++\n  assert.equal(id, f1.outViewID)\n  assert.equal(message, 'hello')\n  if (received >= wanted) {\n    utils.clearFoglets(foglets).then(() => done())\n  }\n}\nf2.onUnicast(receive)\nf3.onUnicast(receive)\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(() => {\n    const peers = f1.getNeighbours()\n    wanted = peers.length\n    f1.sendMulticast(peers, 'hello')\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "46733e86-a162-45c8-91e7-fee3f7f1f121",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should send messages to all peers using broadcast in a network with 2 peers",
            "fullTitle": "Foglet High-level communication should send messages to all peers using broadcast in a network with 2 peers",
            "timedOut": false,
            "duration": 2012,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nlet neighbourID = null\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf2.onBroadcast((id, data) => {\n  assert.equal(id, neighbourID)\n  assert.equal(data, 'hello')\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  neighbourID = f1.outViewID\n  setTimeout(function () {\n    f1.sendBroadcast('hello')\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "8e7b1fea-52e2-4966-a347-715a7d1300d8",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should simply send messages to all peers using broadcast in a 3 peers network",
            "fullTitle": "Foglet High-level communication should simply send messages to all peers using broadcast in a 3 peers network",
            "timedOut": false,
            "duration": 2014,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet cptA = 0\nlet cptB = 0\nconst results = [ '1', '2', '3', '4' ]\nconst totalResult = 8\nconst check = utils.doneAfter(totalResult, () => {\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  f2.onBroadcast((id, message) => {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptA])\n    cptA++\n    check()\n  })\n  f3.onBroadcast((id, message) => {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptB])\n    cptB++\n    check()\n  })\n  setTimeout(() => {\n    f1.sendBroadcast('1')\n    f1.sendBroadcast('2')\n    f1.sendBroadcast('3')\n    f1.sendBroadcast('4')\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "d79cd9d7-9d0e-4f38-882f-791d9664c54f",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should receive broadcasted classically ordered messages in a 3 peers network (1-2-3-4)",
            "fullTitle": "Foglet High-level communication should receive broadcasted classically ordered messages in a 3 peers network (1-2-3-4)",
            "timedOut": false,
            "duration": 2016,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet cptA = 0\nlet cptB = 0\nconst results = [ '1', '2', '3', '4' ]\nconst totalResult = 8\nconst check = utils.doneAfter(totalResult, () => {\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  f2.onBroadcast((id, message) => {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptA])\n    cptA++\n    check()\n  })\n  f3.onBroadcast((id, message) => {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptB])\n    cptB++\n    check()\n  })\n  setTimeout(() => {\n    const id1 = f1.overlay().communication.sendBroadcast('1')\n    const id2 = f1.overlay().communication.sendBroadcast('2', null, id1)\n    const id3 = f1.overlay().communication.sendBroadcast('3', null, id2)\n    f1.overlay().communication.sendBroadcast('4', null, id3)\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "62408cdb-861c-40a2-bec3-db1f37256eaf",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should receive broadcasted weirdly ordered messages in a 3 peers network (1-3-2-4)",
            "fullTitle": "Foglet High-level communication should receive broadcasted weirdly ordered messages in a 3 peers network (1-3-2-4)",
            "timedOut": false,
            "duration": 4023,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet cptA = 0\nlet cptB = 0\nconst results = [ '1', '3', '2', '4' ]\nconst totalResult = 8\nconst check = utils.doneAfter(totalResult, () => {\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  f2.onBroadcast((id, message) => {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptA])\n    cptA++\n    check()\n  })\n  f3.onBroadcast((id, message) => {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptB])\n    cptB++\n    check()\n  })\n  setTimeout(() => {\n    const id1 = f1.overlay().communication.sendBroadcast('1')\n    const id2 = f1.overlay().communication.sendBroadcast('2', null, {e: id1.e, c: 3})\n    setTimeout(() => {\n      f1.overlay().communication.sendBroadcast('3', null, id1)\n      f1.overlay().communication.sendBroadcast('4', null, id2)\n    }, 2000)\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "fcdbc0e2-cf3e-4884-828d-f96ed2baff45",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "f75fecfb-8183-4716-bb10-706ff6f349e8",
          "46733e86-a162-45c8-91e7-fee3f7f1f121",
          "8e7b1fea-52e2-4966-a347-715a7d1300d8",
          "d79cd9d7-9d0e-4f38-882f-791d9664c54f",
          "62408cdb-861c-40a2-bec3-db1f37256eaf",
          "fcdbc0e2-cf3e-4884-828d-f96ed2baff45"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 14115,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "743788b9-5a65-47bd-a993-a07098e4163a",
        "title": "[FOGLET] Other functions tests",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-main-test.js",
        "file": "/tests/foglet-main-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "[FOGLET] getRandomNeighbourId is in getNeighbours",
            "fullTitle": "[FOGLET] Other functions tests [FOGLET] getRandomNeighbourId is in getNeighbours",
            "timedOut": false,
            "duration": 10,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nutils.pathConnect(foglets, 2000).then(() => {\n  console.log('Peers: ', f1.getNeighbours(), f2.getNeighbours())\n  console.log('Random:', f1.getRandomNeighbourId(), f2.getRandomNeighbourId())\n  assert.include(f1.getNeighbours(), f1.getRandomNeighbourId())\n  utils.clearFoglets(foglets).then(() => done())\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "3fd92807-2ed2-4ee7-a228-596bf8f0eeda",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "3fd92807-2ed2-4ee7-a228-596bf8f0eeda"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 10,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "074d7f1a-3682-476f-864b-bddee10ffe60",
        "title": "Middlewares",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-middleware-test.js",
        "file": "/tests/foglet-middleware-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "should use middleware on broadcast",
            "fullTitle": "Middlewares should use middleware on broadcast",
            "timedOut": false,
            "duration": 2009,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf1.use(simpleMiddleware)\nf2.use(simpleMiddleware)\nf2.onBroadcast((id, data) => {\n  assert.equal(data, 'So Long and Thanks for all the Fish')\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    f1.sendBroadcast('So Long')\n  }, 2000)\n})",
            "err": {},
            "isRoot": false,
            "uuid": "47139e4b-37e6-4530-ae93-12da498ad12d",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should use middleware on unicast",
            "fullTitle": "Middlewares should use middleware on unicast",
            "timedOut": false,
            "duration": 2007,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf1.use(simpleMiddleware)\nf2.use(simpleMiddleware)\nf2.onUnicast((id, message) => {\n  assert.equal(message, 'So Long and Thanks for all the Fish')\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    f1.sendUnicast(peers[0], 'So Long')\n  }, 2000)\n})",
            "err": {},
            "isRoot": false,
            "uuid": "14689cd2-5318-4200-bfb5-80806ba566dd",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "47139e4b-37e6-4530-ae93-12da498ad12d",
          "14689cd2-5318-4200-bfb5-80806ba566dd"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 4016,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "6e4c575d-0e28-4295-b59c-8e4e79d2664a",
        "title": "Overlays",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-overlay-test.js",
        "file": "/tests/foglet-overlay-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "should build a simple TMan-based overlay",
            "fullTitle": "Overlays should build a simple TMan-based overlay",
            "timedOut": false,
            "duration": 2126,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "done => {\n    const [ f1, f2 ] = utils.buildFog(Foglet, 2, [\n      {\n        name: 'test-overlay',\n        class: TestOverlay,\n        options: {\n          protocol: 'foglet-test-overlay',\n          signaling: {\n            room: 'foglet-test-overlay-room',\n            address: 'http://localhost:8000/'\n          }\n        }\n      }\n    ])\n    f1.overlay('test-overlay').communication.onUnicast((id, msg) => {\n      assert.equal(msg, 'hello world!')\n      console.log('Got message from: ', id, msg)\n      done()\n    })\n    utils.overlayConnect('test-overlay', 2000, f1, f2)\n      .then(() => {\n        setTimeout(() => {\n          const neighbours = f2.overlay('test-overlay').network.getNeighbours()\n          assert.equal(neighbours.length, 1)\n          f2.overlay('test-overlay').communication.sendUnicast(neighbours[0], 'hello world!')\n        }, 2000)\n      }).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "702e63f1-2480-4d23-b1fe-e23fa96207c7",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should create a internal communication channel correctly",
            "fullTitle": "Overlays should create a internal communication channel correctly",
            "timedOut": false,
            "duration": 2036,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "done => {\n    const [ f1, f2 ] = utils.buildFog(Foglet, 2, [\n      {\n        name: 'test-overlay-communication',\n        class: TestOverlay,\n        options: {\n          protocol: 'foglet-test-overlay-communication',\n          signaling: {\n            address: 'http://localhost:8000/',\n            room: 'foglet-test-overlay-communication-room'\n          }\n        }\n      }\n    ])\n    f1.overlay('test-overlay-communication').network.communication.onUnicast((id, msg) => {\n      assert.equal(msg, 'hello world!')\n      console.log('Got message from: ', id, msg)\n      done()\n    })\n    utils.overlayConnect('test-overlay-communication', 2000, f1, f2)\n      .then(() => {\n        setTimeout(() => {\n          const neighbours = f2.overlay('test-overlay-communication').network.getNeighbours()\n          assert.equal(neighbours.length, 1)\n          f2.overlay('test-overlay-communication').network.communication.sendUnicast(neighbours[0], 'hello world!')\n        }, 2000)\n      }).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "c2f81d84-6c0b-46c0-8592-47d43f008f39",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "702e63f1-2480-4d23-b1fe-e23fa96207c7",
          "c2f81d84-6c0b-46c0-8592-47d43f008f39"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 4162,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "3a872ee5-bebd-4719-9b3a-ac2264edb201",
        "title": "FogletProtocol",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
        "file": "/tests/foglet-protocol-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [],
        "suites": [
          {
            "uuid": "d942e510-f7c1-4e49-956c-1cf5f03ec38a",
            "title": "#unicast",
            "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
            "file": "/tests/foglet-protocol-test.js",
            "beforeHooks": [],
            "afterHooks": [],
            "tests": [],
            "suites": [
              {
                "uuid": "8bd6ae6b-1d9d-4f24-b1af-08927d5c79fc",
                "title": "#communication",
                "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
                "file": "/tests/foglet-protocol-test.js",
                "beforeHooks": [],
                "afterHooks": [],
                "tests": [
                  {
                    "title": "should receive messages from remote services",
                    "fullTitle": "FogletProtocol #unicast #communication should receive messages from remote services",
                    "timedOut": false,
                    "duration": 1012,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const expected = 'Hello world!'\n        const p1 = new UnicastProtocol(f1)\n        const p2 = new UnicastProtocol(f2, (id, msg) => {\n          assert.equal(msg, expected)\n        }, () => {\n          utils.clearFoglets(foglets).then(() => done())\n        })\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], expected)\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "c3cd85d0-6925-4a53-ae4c-7b6c19a06e6d",
                    "isHook": false,
                    "skipped": false
                  },
                  {
                    "title": "should allow peers to reply to service calls",
                    "fullTitle": "FogletProtocol #unicast #communication should allow peers to reply to service calls",
                    "timedOut": false,
                    "duration": 1009,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastProtocol(f1)\n        const p2 = new UnicastProtocol(f2, (id, msg, reply) => {\n          reply(msg + ' world!')\n        })\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], 'Hello')\n              .then(msg => {\n                assert.equal(msg, 'Hello world!')\n                utils.clearFoglets(foglets).then(() => done())\n              })\n              .catch(() => {\n                utils.clearFoglets(foglets).then(() => done())\n              })\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "b33412c0-788f-4b66-885b-6b7a58e9ac12",
                    "isHook": false,
                    "skipped": false
                  },
                  {
                    "title": "should allow peers to reject service calls",
                    "fullTitle": "FogletProtocol #unicast #communication should allow peers to reject service calls",
                    "timedOut": false,
                    "duration": 1010,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastProtocol(f1)\n        const p2 = new UnicastProtocol(f2, (id, msg, reply, reject) => {\n          reject(msg + ' world!')\n        })\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], 'Hello')\n              .then(msg => {\n                utils.clearFoglets(foglets).then(() => done(new Error('Message should have rejected but instead got reply with ' + msg)))\n              })\n              .catch(msg => {\n                assert.equal(msg, 'Hello world!')\n                utils.clearFoglets(foglets).then(() => done())\n              })\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "1031e555-3829-4346-86dc-eca3d9e9a8f4",
                    "isHook": false,
                    "skipped": false
                  }
                ],
                "suites": [],
                "passes": [
                  "c3cd85d0-6925-4a53-ae4c-7b6c19a06e6d",
                  "b33412c0-788f-4b66-885b-6b7a58e9ac12",
                  "1031e555-3829-4346-86dc-eca3d9e9a8f4"
                ],
                "failures": [],
                "pending": [],
                "skipped": [],
                "duration": 3031,
                "root": false,
                "rootEmpty": false,
                "_timeout": 20000
              },
              {
                "uuid": "4c90c89d-1e4e-46b7-a106-af868a493157",
                "title": "#hooks",
                "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
                "file": "/tests/foglet-protocol-test.js",
                "beforeHooks": [],
                "afterHooks": [],
                "tests": [
                  {
                    "title": "should allow before hooks on send & receive",
                    "fullTitle": "FogletProtocol #unicast #hooks should allow before hooks on send & receive",
                    "timedOut": false,
                    "duration": 1015,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        UnicastHookProtocol = defineProtocol('unicast-protocol-with-hooks')`\n          init\n          ${initProtocol}\n          get\n          ${function (service) {\n    service.is.unicast()\n    service.on.receive(function (id, msg) {\n      if (this._callback) this._callback(id, msg)\n      if (this._done) this._done()\n    })\n    service.before.send(function (msg) {\n      return msg + ' and Thanks for'\n    })\n    service.before.receive(function (msg) {\n      return msg + ' all the Fish'\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastHookProtocol(f1)\n        const p2 = new UnicastHookProtocol(f2, (id, msg) => {\n          assert.equal(msg, 'So Long and Thanks for all the Fish')\n        }, () => {\n          utils.clearFoglets(foglets).then(() => done())\n        })\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], 'So Long')\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "47a9542f-9222-46bd-af7a-714dc4ef8f3b",
                    "isHook": false,
                    "skipped": false
                  },
                  {
                    "title": "should allow after hooks on send & receive",
                    "fullTitle": "FogletProtocol #unicast #hooks should allow after hooks on send & receive",
                    "timedOut": false,
                    "duration": 1007,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        const check = utils.doneAfter(2, () => {\n          utils.clearFoglets(foglets).then(() => done())\n        })\n        UnicastHookProtocol = defineProtocol('unicast-protocol-with-hooks')`\n          get\n          ${function (service) {\n    service.is.unicast()\n    service.on.receive(function () {})\n    service.after.send(function (msg) {\n      assert.equal(msg, 'So Long')\n      check()\n    })\n    service.after.receive(function (msg) {\n      assert.equal(msg, 'So Long')\n      check()\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastHookProtocol(f1)\n        const p2 = new UnicastHookProtocol(f2)\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], 'So Long')\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "5f2fd78b-2d8f-45ba-8378-d38c25188ae2",
                    "isHook": false,
                    "skipped": false
                  }
                ],
                "suites": [],
                "passes": [
                  "47a9542f-9222-46bd-af7a-714dc4ef8f3b",
                  "5f2fd78b-2d8f-45ba-8378-d38c25188ae2"
                ],
                "failures": [],
                "pending": [],
                "skipped": [],
                "duration": 2022,
                "root": false,
                "rootEmpty": false,
                "_timeout": 20000
              }
            ],
            "passes": [],
            "failures": [],
            "pending": [],
            "skipped": [],
            "duration": 0,
            "root": false,
            "rootEmpty": false,
            "_timeout": 20000
          },
          {
            "uuid": "3ae0d01d-89e4-4620-9456-7425e1034d6d",
            "title": "#broadcast",
            "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
            "file": "/tests/foglet-protocol-test.js",
            "beforeHooks": [],
            "afterHooks": [],
            "tests": [],
            "suites": [
              {
                "uuid": "003312e8-6a83-41e3-b246-09783941cc9d",
                "title": "#communication",
                "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
                "file": "/tests/foglet-protocol-test.js",
                "beforeHooks": [],
                "afterHooks": [],
                "tests": [
                  {
                    "title": "should receive messages from remote services",
                    "fullTitle": "FogletProtocol #broadcast #communication should receive messages from remote services",
                    "timedOut": false,
                    "duration": 1009,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const expected = 'Hello world!'\n        const p1 = new BroadcastProtocol(f1)\n        const p2 = new BroadcastProtocol(f2, (id, msg) => {\n          assert.equal(msg, expected)\n        }, () => {\n          utils.clearFoglets(foglets).then(() => done())\n        })\n        utils.pathConnect(foglets, 2000).then(() => {\n          setTimeout(function () {\n            p1.get(expected)\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "41273cca-b7a4-4960-ae71-e97d18b97ce0",
                    "isHook": false,
                    "skipped": false
                  }
                ],
                "suites": [],
                "passes": [
                  "41273cca-b7a4-4960-ae71-e97d18b97ce0"
                ],
                "failures": [],
                "pending": [],
                "skipped": [],
                "duration": 1009,
                "root": false,
                "rootEmpty": false,
                "_timeout": 20000
              },
              {
                "uuid": "7fca2a3c-eee9-4b7a-8c35-97012c6bf5d1",
                "title": "#hooks",
                "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
                "file": "/tests/foglet-protocol-test.js",
                "beforeHooks": [],
                "afterHooks": [],
                "tests": [
                  {
                    "title": "should allow before hooks on send & receive",
                    "fullTitle": "FogletProtocol #broadcast #hooks should allow before hooks on send & receive",
                    "timedOut": false,
                    "duration": 1010,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        BroadcastHookProtocol = defineProtocol('broadcast-protocol-with-hooks')`\n          init\n          ${initProtocol}\n          get\n          ${function (service) {\n    service.is.broadcast()\n    service.on.receive(function (id, msg) {\n      if (this._callback) this._callback(id, msg)\n      if (this._done) this._done()\n    })\n    service.before.send(function (msg) {\n      return msg + ' and Thanks for'\n    })\n    service.before.receive(function (msg) {\n      return msg + ' all the Fish'\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new BroadcastHookProtocol(f1)\n        const p2 = new BroadcastHookProtocol(f2, (id, msg) => {\n          assert.equal(msg, 'So Long and Thanks for all the Fish')\n        }, () => {\n          utils.clearFoglets(foglets).then(() => done())\n        })\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get('So Long')\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "d9d56266-0e72-4236-95ee-167e5dc0b097",
                    "isHook": false,
                    "skipped": false
                  },
                  {
                    "title": "should allow after hooks on send & receive",
                    "fullTitle": "FogletProtocol #broadcast #hooks should allow after hooks on send & receive",
                    "timedOut": false,
                    "duration": 1010,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        const check = utils.doneAfter(2, () => {\n          utils.clearFoglets(foglets).then(() => done())\n        })\n        BroadcastHookProtocol = defineProtocol('broadcast-protocol-with-hooks')`\n          get\n          ${function (service) {\n    service.is.broadcast()\n    service.on.receive(function () {})\n    service.after.send(function (msg) {\n      assert.equal(msg, 'So Long')\n      check()\n    })\n    service.after.receive(function (msg) {\n      assert.equal(msg, 'So Long')\n      check()\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new BroadcastHookProtocol(f1)\n        const p2 = new BroadcastHookProtocol(f2)\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get('So Long')\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "352cd2e7-eeec-4378-93a0-89963d05e438",
                    "isHook": false,
                    "skipped": false
                  }
                ],
                "suites": [],
                "passes": [
                  "d9d56266-0e72-4236-95ee-167e5dc0b097",
                  "352cd2e7-eeec-4378-93a0-89963d05e438"
                ],
                "failures": [],
                "pending": [],
                "skipped": [],
                "duration": 2020,
                "root": false,
                "rootEmpty": false,
                "_timeout": 20000
              }
            ],
            "passes": [],
            "failures": [],
            "pending": [],
            "skipped": [],
            "duration": 0,
            "root": false,
            "rootEmpty": false,
            "_timeout": 20000
          }
        ],
        "passes": [],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 0,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "25c4d079-b515-4a41-b396-56f394007dd5",
        "title": "[SIGNALING] Direct/Signaling connections",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-signaling-test.js",
        "file": "/tests/foglet-signaling-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "direct connection, return true when connected",
            "fullTitle": "[SIGNALING] Direct/Signaling connections direct connection, return true when connected",
            "timedOut": false,
            "duration": 7,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nutils.pathConnect(foglets, 2000).then((status) => {\n  assert.isOk(status, 'Status Must be true.')\n  utils.clearFoglets(foglets)\n  done()\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "35a9292b-b44d-4cc3-b5bf-7eb7848049bb",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "signaling connection alone, return true when connected",
            "fullTitle": "[SIGNALING] Direct/Signaling connections signaling connection alone, return true when connected",
            "timedOut": false,
            "duration": 10,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 1, [], [{ url: 'stun:global.stun.twilio.com:3478?transport=udp' }])\nconst f1 = foglets[0]\nf1.share()\nf1.connection().then((status) => {\n  assert.isOk(status, 'Status Must be true.')\n  utils.clearFoglets(foglets)\n  done()\n}).catch(e => {\n  done(e)\n})",
            "err": {},
            "isRoot": false,
            "uuid": "b4101840-bfd6-4172-a32f-6745eed330f2",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "signaling connection (2 peers network), return true when connected",
            "fullTitle": "[SIGNALING] Direct/Signaling connections signaling connection (2 peers network), return true when connected",
            "timedOut": false,
            "duration": 37,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2, [], [{ url: 'stun:global.stun.twilio.com:3478?transport=udp' }])\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf1.onUnicast((id, msg) => {\n  assert.equal(msg, 'ping')\n  utils.clearFoglets(foglets)\n  done()\n})\nf1.share()\nf1.connection().then((status) => {\n  f2.share()\n  assert.isOk(status, 'Status Must be true.')\n  f2.connection().then((status) => {\n    assert.isOk(status, 'Status Must be true.')\n    assert.equal(f2.getNeighbours().length, 1)\n    f2.sendUnicast(f2.getNeighbours()[0], 'ping')\n  }).catch(done)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "7fce11c4-0b66-426a-84a7-d139075b1ca9",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "35a9292b-b44d-4cc3-b5bf-7eb7848049bb",
          "b4101840-bfd6-4172-a32f-6745eed330f2",
          "7fce11c4-0b66-426a-84a7-d139075b1ca9"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 54,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "734cc61d-dd64-49e5-993a-497a9d52d372",
        "title": "Foglet streaming communication",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-streams-test.js",
        "file": "/tests/foglet-streams-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "should stream data to a neighbour using unicast",
            "fullTitle": "Foglet streaming communication should stream data to a neighbour using unicast",
            "timedOut": false,
            "duration": 2037,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nlet acc = ''\nf2.onStreamUnicast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('data', data => { acc += data })\n  message.on('end', () => {\n    assert.equal(acc, 'Hello world!Family!')\n    utils.clearFoglets(foglets)\n    done()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    const stream = f1.streamUnicast(peers[0])\n    stream.write('Hello ')\n    stream.write('world!')\n    stream.write('Family!')\n    stream.end()\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "f430ad4e-7e31-4a25-b1e7-ad6d99abd10c",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should stream trailing data to a neighbour using unicast",
            "fullTitle": "Foglet streaming communication should stream trailing data to a neighbour using unicast",
            "timedOut": false,
            "duration": 2013,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf2.onStreamUnicast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('data', () => null)\n  message.on('end', () => {\n    assert.equal(message.trailers.length, 1)\n    assert.equal(message.trailers[0], 'Hello world!Family!')\n    utils.clearFoglets(foglets)\n    done()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    const stream = f1.streamUnicast(peers[0])\n    stream.write('foo')\n    stream.addTrailer('Hello world!Family!')\n    stream.end()\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "92cbf6b2-80b6-4246-9d05-21a5ccd4a784",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should transmit an error through a stream when using unicast",
            "fullTitle": "Foglet streaming communication should transmit an error through a stream when using unicast",
            "timedOut": false,
            "duration": 2011,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst check = utils.doneAfter(2, () => {\n  utils.clearFoglets(foglets)\n  done()\n})\nf2.onStreamUnicast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('error', err => {\n    assert.equal(err, 'Everything goes wrong!')\n    check()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    const stream = f1.streamUnicast(peers[0])\n    stream.on('error', () => check())\n    stream.destroy('Everything goes wrong!')\n    stream.end()\n  }, 2000)\n})",
            "err": {},
            "isRoot": false,
            "uuid": "a6d26960-774a-415b-9bcd-96c268c47e16",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should stream data to all peers using broadcast in a network with 2 peers",
            "fullTitle": "Foglet streaming communication should stream data to all peers using broadcast in a network with 2 peers",
            "timedOut": false,
            "duration": 2011,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nlet acc = ''\nf2.onStreamBroadcast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('data', data => { acc += data })\n  message.on('end', () => {\n    assert.equal(acc, 'Hello world!Family!')\n    utils.clearFoglets(foglets)\n    done()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    const stream = f1.streamBroadcast()\n    stream.write('Hello ')\n    stream.write('world!')\n    stream.write('Family!')\n    stream.end()\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "f986e411-63e4-400a-b757-59e7d68ac17c",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should stream data to all peers using broadcast in a network with 3 peers",
            "fullTitle": "Foglet streaming communication should stream data to all peers using broadcast in a network with 3 peers",
            "timedOut": false,
            "duration": 2017,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet accA = ''\nlet accB = ''\nconst check = utils.doneAfter(2, () => {\n  utils.clearFoglets(foglets)\n  done()\n})\nf2.onStreamBroadcast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('data', data => { accA += data })\n  message.on('end', () => {\n    assert.equal(accA, 'Hello world!Family!')\n    check()\n  })\n})\nf3.onStreamBroadcast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('data', data => { accB += data })\n  message.on('end', () => {\n    assert.equal(accB, 'Hello world!Family!')\n    check()\n  })\n})\nutils.pathConnect(foglets, 1000).then(() => {\n  setTimeout(function () {\n    const stream = f1.streamBroadcast()\n    stream.write('Hello ')\n    stream.write('world!')\n    stream.write('Family!')\n    stream.end()\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "c45e9f63-ee60-47a5-b402-915d9255fddf",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should transmit an error through a stream when using broadcast",
            "fullTitle": "Foglet streaming communication should transmit an error through a stream when using broadcast",
            "timedOut": false,
            "duration": 2017,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nconst check = utils.doneAfter(3, () => {\n  utils.clearFoglets(foglets)\n  done()\n})\nf2.onStreamBroadcast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('error', err => {\n    assert.equal(err, 'Everything goes wrong!')\n    check()\n  })\n})\nf3.onStreamBroadcast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('error', err => {\n    assert.equal(err, 'Everything goes wrong!')\n    check()\n  })\n})\nutils.pathConnect(foglets, 1000).then(() => {\n  setTimeout(function () {\n    const stream = f1.streamBroadcast()\n    stream.on('error', () => check())\n    stream.destroy('Everything goes wrong!')\n    stream.end()\n  }, 2000)\n})",
            "err": {},
            "isRoot": false,
            "uuid": "d1cc36b2-7bc3-4cb1-8d11-b20a8f71d1a3",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "f430ad4e-7e31-4a25-b1e7-ad6d99abd10c",
          "92cbf6b2-80b6-4246-9d05-21a5ccd4a784",
          "a6d26960-774a-415b-9bcd-96c268c47e16",
          "f986e411-63e4-400a-b757-59e7d68ac17c",
          "c45e9f63-ee60-47a5-b402-915d9255fddf",
          "d1cc36b2-7bc3-4cb1-8d11-b20a8f71d1a3"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 12106,
        "root": false,
        "rootEmpty": false,
        "_timeout": 30000
      }
    ],
    "passes": [],
    "failures": [],
    "pending": [],
    "skipped": [],
    "duration": 0,
    "root": true,
    "rootEmpty": true,
    "_timeout": 30000
  },
  "copyrightYear": 2018
}