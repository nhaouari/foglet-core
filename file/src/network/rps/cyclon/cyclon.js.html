<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">src/network/rps/cyclon/cyclon.js | foglet-core</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Core of the foglet library"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="foglet-core"><meta property="twitter:description" content="Core of the foglet library"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ran3d/foglet-core"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/foglet.js~Foglet.html">Foglet</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#fprotocol">fprotocol</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/answer-queue.js~AnswerQueue.html">AnswerQueue</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/foglet-protocol.js~FogletProtocol.html">FogletProtocol</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-define">define</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#fprotocol-builders">fprotocol/builders</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/builders/abstract-method-builder.js~AbstractMethodBuilder.html">AbstractMethodBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/builders/broadcast-builder.js~BroadcastBuilder.html">BroadcastBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/builders/init-builder.js~InitBuilder.html">InitBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/builders/service-builder.js~ServiceBuilder.html">ServiceBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/builders/unicast-builder.js~UnicastBuilder.html">UnicastBuilder</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network">network</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/network-manager.js~NetworkManager.html">NetworkManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/network.js~Network.html">Network</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-OverlayConfig">OverlayConfig</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-abstract">network/abstract</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/abstract/abstract-network.js~AbstractNetwork.html">AbstractNetwork</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/abstract/abstract-overlay.js~AbstractOverlay.html">AbstractOverlay</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/abstract/tman-overlay.js~TManOverlay.html">TManOverlay</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-communication">network/communication</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/communication.js~Communication.html">Communication</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-communication-abstract">network/communication/abstract</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/abstract/abstract-broadcast.js~AbstractBroadcast.html">AbstractBroadcast</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/abstract/abstract-unicast.js~AbstractUnicast.html">AbstractUnicast</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/abstract/communication-protocol.js~CommunicationProtocol.html">CommunicationProtocol</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-communication-broadcast">network/communication/broadcast</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/broadcast/broadcast.js~Broadcast.html">Broadcast</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-communication-stream">network/communication/stream</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/stream/stream-message.js~StreamMessage.html">StreamMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/stream/stream-request.js~StreamRequest.html">StreamRequest</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-communication-unicast">network/communication/unicast</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/unicast/unicast.js~Unicast.html">Unicast</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-rps">network/rps</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/rps/cyclon-adapter.js~CyclonAdapter.html">CyclonAdapter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/rps/sprayAdapter.js~SprayAdapter.html">SprayAdapter</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-rps-cyclon">network/rps/cyclon</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/rps/cyclon/cyclon.js~Cyclon.html">Cyclon</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/rps/cyclon/partialview.js~PartialView.html">PartialView</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-signaling">network/signaling</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/signaling/signaling.js~Signaling.html">Signaling</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#utils">utils</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/media.js~Media.html">Media</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/middleware-registry.js~MiddlewareRegistry.html">MiddlewareRegistry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/simple-peer-moc.js~SimplePeerAbstract.html">SimplePeerAbstract</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/ssh.js~SshControl.html">SshControl</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/network/rps/cyclon/cyclon.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const N2N = require(&apos;n2n-overlay-wrtc&apos;)
const lmerge = require(&apos;lodash.merge&apos;)
const uniqid = require(&apos;uuid/v4&apos;)
const PV = require(&apos;./partialview&apos;)
const debug = (require(&apos;debug&apos;))(&apos;cyclon&apos;)

/**
 * Implementation of CYCLON: Inexpensive Membership Management for Unstructured P2P Overlays
 * Spyros Voulgaris,1,2 Daniela Gavidia,1 and Maarten van Steen1
 * @article{voulgaris2005cyclon,
    title={Cyclon: Inexpensive membership management for unstructured p2p overlays},
    author={Voulgaris, Spyros and Gavidia, Daniela and Van Steen, Maarten},
    journal={Journal of Network and Systems Management},
    volume={13},
    number={2},
    pages={197--217},
    year={2005},
    publisher={Springer}
  }
 *
 * @type {[type]}
 */
module.exports = class Cyclon extends N2N {
  constructor (options) {
    const DEFAULT_OPTIONS = {
      pid: &apos;cyclon&apos;,
      peer: uniqid(),
      maxPeers: 5,
      timeoutnetwork: 20 * 1000,
      timeoutconnection: 20 * 1000,
      retry: 5,
      delta: 30 * 1000,
      timeout: 30 * 1000
    }
    super(lmerge(DEFAULT_OPTIONS, options))
    this._partialView = new PV()
    this._periodic = undefined
    this.on(&apos;receive&apos;, (id, msg) =&gt; this._receive(id, msg))
    this.on(&apos;open&apos;, (peerId) =&gt; {
      this._open(peerId)
    })
    this.on(&apos;close&apos;, (peerId) =&gt; {
      this._close(peerId)
    })
    this.on(&apos;fail&apos;, (peerId) =&gt; {
      this._onArcDown(peerId)
    })
  }

  get partialView () {
    return this._partialView
  }

  /**
   * Joining a network.
   * @param {callback} sender Function that will be called each time an offer
   * arrives to this peer. It is the responsability of the caller to send
   * these offer (using sender) to the contact inside the network.
   * @returns {Promise} A promise that is resolved when the peer joins the
   * network -- the resolve contains the peerId; rejected after a timeout, or
   * already connected state.
   */
  join (sender) {
    return new Promise((resolve, reject) =&gt; {
      let to = setTimeout(() =&gt; {
        reject(new Error(&apos;conenction timed out&apos;))
      }, this.options.timeoutconnection)
      // #2 very first call, only done once
      this.once(&apos;open&apos;, (peerId) =&gt; {
        this.send(peerId, {type: &apos;MJoin&apos;}, this.options.retry).then(() =&gt; {
          clearTimeout(to)
          this._start() // start shuffling process
          resolve(peerId)
        }).catch(() =&gt; {
          reject(new Error(&apos;failed to send a MJoin message after establishing the connection. Please report.&apos;))
        })
      })
      this.connect(sender)
    })
  }

  _open (peerId) {
    debug(&apos;[%s] %s ===&gt; %s&apos;, this.PID, this.PEER, peerId)
    if (!this._partialView.has(peerId)) this._partialView.add(peerId)
    if (this._partialView.size &gt; this.options.maxPeers) {
      this.disconnect(peerId)
    }
  }

  /**
   * @private Behavior when a connection is closed.
   * @param {string} peerId The identifier of the removed arc.
   */
  _close (peerId) {
    debug(&apos;[%s] %s =&#x2020;=&gt; %s&apos;, this.PID, this.PEER, peerId)
    if (this._partialView.has(peerId)) this._partialView.delete(peerId)
  }

  _onJoin (id) {
    if (this._partialView.size &gt; 0) {
      // #1 all neighbors -&gt; peerId
      debug(&apos;[%s] %s ===&gt; join %s ===&gt; %s neighbors&apos;, this.PID, id, this.PEER, this._partialView.size)
      this._partialView.forEach((ages, neighbor) =&gt; {
        this.connect(id, neighbor)
      })
    } else {
      // #2 Seems like a 2-peer network;  this -&gt; peerId;
      debug(&apos;[%s] %s ===&gt; join %s ===&gt; %s&apos;, this.PID, id, this.PEER, id)
      this.connect(null, id)
    };
  }

  _onLeave (id) {
    debug(&apos;%s: just left the game!&apos;, id)
  }

  _start () {
    debug(&apos;[%s] starting periodic shuffling with period=%f&apos;, this.PEER, this.options.delta)
    this._periodic = setInterval(() =&gt; {
      this.exchange()
    }, this.options.delta)
  }

  _stop () {
    clearInterval(this._periodic)
  }

  /**
   * @private Called each time this protocol receives a message.
   * @param {string} peerId The identifier of the peer that sent the message.
   * @param {object|MExchange|MJoin} message The message received.
   */
  _receive (peerId, message) {
    if (message.type &amp;&amp; message.type === &apos;MExchange&apos;) {
      this._onExchange(peerId, message)
    } else if (message.type &amp;&amp; message.type === &apos;MExchangeBack&apos;) {
      this.emit(&apos;MExchangeBack-&apos; + message.id, peerId, message)
    } else if (message.type &amp;&amp; message.type === &apos;MJoin&apos;) {
      this._onJoin(peerId)
    } else if (message.type &amp;&amp; message.type === &apos;MLeave&apos;) {
      this._onLeave(peerId)
    } else if (message.type &amp;&amp; message.type === &apos;MBridge&apos;) {
      this._onBridge(message.from, message.to)
    } else {
      throw new Error(&apos;_receive, message unhandled&apos;)
    }
  }

  _exchange () {
    return this.exchange()
  }

  exchange () {
    this.emit(&apos;begin-shuffle&apos;)
    return new Promise((resolve, reject) =&gt; {
      if (this._partialView.size === 0) resolve()

      // 1. Increase by one the age of all neighbors.
      this._partialView.increment()
      // 2. Select neighbor Q with the highest age among all neighbors, and l &#x2212; 1
      // other random neighbors.
      // const keys = [...this._partialView.keys()]
      const oldest = this._partialView.oldest // keys[Math.floor(Math.random() * keys.length)]
      const sample = this._getSample(this.options.maxPeers)
      // 3. Replace Q&#x2019;s entry with a new entry of age 0 and with P&#x2019;s address.
      this._partialView.removeOldest(oldest)
      this._partialView.add(oldest)
      sample.map(samp =&gt; {
        if (samp.id === oldest) {
          samp.id = this.getInviewId()
          samp.age = 0
        }
      })
      debug(&apos;[%s] Starting to exchange with %s with a sample of size: %f&apos;, this.PEER, oldest, sample.length)
      // 4. Send the updated subset to peer Q.
      // need to try with another peer if it fails
      const msgid = uniqid()
      this.send(oldest, {
        type: &apos;MExchange&apos;,
        id: msgid,
        from: this.getInviewId(),
        sample
      }, this.options.retry).then(() =&gt; {
        // put a timeout on the reply in order to skip the round
        let timeout = setTimeout(() =&gt; {
          this.removeAllListeners(&apos;MExchangeBack-&apos; + msgid)
          resolve() // skip the round or perhaps reject?
        }, this.options.timeoutnetwork)
        // 5. Receive from Q a subset of no more that i of its own entries
        this.once(&apos;MExchangeBack-&apos; + msgid, (id, message) =&gt; {
          clearTimeout(timeout)
          // 6. Discard entries pointing at P and entries already contained in P&#x2019;s
          // cache.
          // at least put the id of the peer we just exchange samples into the list of arcs to remove
          const tokeep = message.sample.filter(samp =&gt; {
            if (this._partialView.has(samp.id) || samp.id === oldest || samp.id === id) {
              return false
            } else {
              return true
            }
          })
          // 7. Update P&#x2019;s cache to include all remaining entries, by firstly using empty
          // cache slots (if any), and secondly replacing entries among the ones sent to Q.
          for (let i = 0; i &lt; tokeep.length; i++) {
            const keep = tokeep[i]
            if (this._partialView.size &gt;= this.options.maxPeers) {
              const rn = Math.floor(Math.random() * sample.length)
              const idrn = sample[rn].id
              sample.splice(rn, 1)
              debug(&apos;[%s] replacing entry %s by %s&apos;, this.PEER, idrn, keep.id)
              this.disconnect(idrn)
              this._partialView.removeAll(idrn)
            }
            this.send(id, {
              type: &apos;MBridge&apos;,
              from: this.getInviewId(),
              to: keep.id
            }, this.options.retry).then(() =&gt; {
              //
            }).catch(e =&gt; {
              // console.log(e)
            })
          }
          resolve()
        })
      }).catch(e =&gt; {
        console.log(&apos;%s Error when sending the sample to %s&apos;, this.PEER, oldest)
        // try with another peers or skip
        resolve()
      })
    }).then(() =&gt; {
      this.emit(&apos;end-shuffle&apos;)
      return Promise.resolve()
    }).catch(e =&gt; {
      this.emit(&apos;end-shuffle&apos;)
      return Promise.reject(e)
    })
  }

  _onExchange (id, message) {
    // the receiving node Q replies by sending back a random subset of at most l of its neighbors,
    //  and updates its own cache to accommodate all received entries.
    //  It does not increase, though, any entry&#x2019;s age until its own turn comes to initiate a shuffle.
    const saveSample = message.sample.slice(0)
    const saveOriginator = String(message.from)
    const sample = this._getSample(this.options.maxPeers)
    debug(&apos;[%s] Answer to a an exchange demande with %s with a sample of size: %f&apos;, this.PEER, saveOriginator, sample.length)
    // now reply
    message.type = &apos;MExchangeBack&apos;
    message.sample = sample
    message.from = this.getInviewId()
    this.send(id, message, this.options.retry)
    // 6. Discard entries pointing at P and entries already contained in P&#x2019;s
    // cache.
    const tokeep = saveSample.filter(samp =&gt; {
      if (this._partialView.has(samp.id)) {
        return false
      } else {
        return true
      }
    })
    // 7. Update P&#x2019;s cache to include all remaining entries, by firstly using empty
    // cache slots (if any), and secondly replacing entries among the ones sent to Q.
    for (let i = 0; i &lt; tokeep.length; i++) {
      const keep = tokeep[i]
      if (this._partialView.size &gt;= this.options.maxPeers) {
        // replacement of links into our pv...
        const rn = Math.floor(Math.random() * sample.length)
        const idrn = sample[rn].id
        sample.splice(rn, 1)
        debug(&apos;[%s] replacing entry %s by %s&apos;, this.PEER, idrn, keep.id)
        this.disconnect(idrn)
        this._partialView.removeAll(idrn)
      }
      this.send(id, {
        type: &apos;MBridge&apos;,
        from: this.getInviewId(),
        to: keep.id
      }, this.options.retry).then(() =&gt; {
        //
      }).catch(e =&gt; {
        // console.log(e)
      })
    }
  }

  _getSample (size) {
    let sample = []
    // #1 create a flatten version of the partial view
    let flatten = []
    this._partialView.forEach((ages, neighbor) =&gt; {
      flatten.push({id: neighbor, age: ages[0]})
    })
    // #2 process the size of the sample, at maximum maxPeers
    const sampleSize = Math.min(flatten.length, size)
    // #3 add neighbors to the sample chosen at random
    while (sample.length &lt; sampleSize) {
      const rn = Math.floor(Math.random() * flatten.length)
      sample.push(flatten[rn])
      flatten.splice(rn, 1)
    };
    return sample
  }

  /**
   * Get k neighbors from the partial view. If k is not reached, it tries to
   * fill the gap with neighbors from the inview.  It is worth noting that
   * each peer controls its outview but not its inview. The more the neigbhors
   * from the outview the better.
   * @param {number} k The number of neighbors requested. If k is not defined,
   * it returns every known identifiers of the partial view.
   * @return {string[]} Array of identifiers.
   */
  getPeers (k) {
    let peers = []
    if (typeof k === &apos;undefined&apos;) {
      // #1 get all the partial view
      this._partialView.forEach((occ, peerId) =&gt; {
        peers.push(peerId)
      })
    } else {
      // #2 get random identifier from outview
      let out = []
      this._partialView.forEach((ages, peerId) =&gt; out.push(peerId))
      while (peers.length &lt; k &amp;&amp; out.length &gt; 0) {
        let rn = Math.floor(Math.random() * out.length)
        peers.push(out[rn])
        out.splice(rn, 1)
      };
      // #3 get random identifier from the inview to fill k-entries
      let inView = []
      this.i.forEach((occ, peerId) =&gt; inView.push(peerId))
      while (peers.length &lt; k &amp;&amp; inView.length &gt; 0) {
        let rn = Math.floor(Math.random() * inView.length)
        peers.push(inView[rn])
        inView.splice(rn, 1)
      };
    };
    // debug(&apos;[%s] %s provides %s peers&apos;, this.PID, this.PEER, peers.length)
    return peers
  }

  _onBridge (from, to) {
    // debug(&apos;[%s] Bridge bewteen (%s,%s)&apos;, this.PEER, from, to)
    if (from !== to) this.connect(from, to)
  }

  /**
   * @private A connection failed to establish properly, systematically
   * duplicates an element of the partial view.
   * @param {string|null} peerId The identifier of the peer we failed to
   * establish a connection with. Null if it was yet to be known.
   */
  _onArcDown (peerId) {
    debug(&apos;[%s] ONARCDOWN ==&gt; %s =X&gt; %s&apos;, this.PID, this.PEER, peerId || &apos;unknown&apos;)
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
