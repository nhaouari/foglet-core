<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/utils/media.js | foglet-core</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Core of the foglet library"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="foglet-core"><meta property="twitter:description" content="Core of the foglet library"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ran3d/foglet-core"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/foglet.js~Foglet.html">Foglet</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#fprotocol">fprotocol</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/answer-queue.js~AnswerQueue.html">AnswerQueue</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/foglet-protocol.js~FogletProtocol.html">FogletProtocol</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-define">define</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#fprotocol-builders">fprotocol/builders</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/builders/abstract-method-builder.js~AbstractMethodBuilder.html">AbstractMethodBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/builders/broadcast-builder.js~BroadcastBuilder.html">BroadcastBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/builders/init-builder.js~InitBuilder.html">InitBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/builders/service-builder.js~ServiceBuilder.html">ServiceBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/fprotocol/builders/unicast-builder.js~UnicastBuilder.html">UnicastBuilder</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network">network</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/network-manager.js~NetworkManager.html">NetworkManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/network.js~Network.html">Network</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-OverlayConfig">OverlayConfig</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-abstract">network/abstract</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/abstract/abstract-network.js~AbstractNetwork.html">AbstractNetwork</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/abstract/abstract-overlay.js~AbstractOverlay.html">AbstractOverlay</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/abstract/tman-overlay.js~TManOverlay.html">TManOverlay</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-communication">network/communication</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/communication.js~Communication.html">Communication</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-communication-abstract">network/communication/abstract</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/abstract/abstract-broadcast.js~AbstractBroadcast.html">AbstractBroadcast</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/abstract/abstract-unicast.js~AbstractUnicast.html">AbstractUnicast</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/abstract/communication-protocol.js~CommunicationProtocol.html">CommunicationProtocol</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-communication-broadcast">network/communication/broadcast</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/broadcast/broadcast.js~Broadcast.html">Broadcast</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-communication-stream">network/communication/stream</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/stream/stream-message.js~StreamMessage.html">StreamMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/stream/stream-request.js~StreamRequest.html">StreamRequest</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-communication-unicast">network/communication/unicast</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/communication/unicast/unicast.js~Unicast.html">Unicast</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-rps">network/rps</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/rps/cyclon-adapter.js~CyclonAdapter.html">CyclonAdapter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/rps/sprayAdapter.js~SprayAdapter.html">SprayAdapter</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-rps-cyclon">network/rps/cyclon</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/rps/cyclon/cyclon.js~Cyclon.html">Cyclon</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/rps/cyclon/partialview.js~PartialView.html">PartialView</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#network-signaling">network/signaling</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/network/signaling/signaling.js~Signaling.html">Signaling</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#utils">utils</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/media.js~Media.html">Media</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/middleware-registry.js~MiddlewareRegistry.html">MiddlewareRegistry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/simple-peer-moc.js~SimplePeerAbstract.html">SimplePeerAbstract</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/ssh.js~SshControl.html">SshControl</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/utils/media.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const CommunicationProtocol = require(&apos;../network/communication/abstract/communication-protocol&apos;)
const Communication = require(&apos;../network/communication/communication&apos;)
const debug = (require(&apos;debug&apos;))(&apos;foglet-core:media&apos;)
const uuid = require(&apos;uuid/v4&apos;)
const lmerge = require(&apos;lodash.merge&apos;)
const MediaRecorderStream = require(&apos;media-recorder-stream&apos;)
const MediaSource = require(&apos;mediasource&apos;)
const Stream = require(&apos;stream&apos;)

class ReadableFromStream extends Stream.Readable {
  constructor (source, parent, options) {
    super(options)
    this.source = source
    this.parent = parent
    this.objectMode = true
    this.count = 0
    let stack = &apos;&apos;
    this.source.on(&apos;data&apos;, (data) =&gt; {
      if (this.count === 0) {
        if (!this.parent._activeStream.has(data.id)) {
          debug(&apos;Setting options for %s&apos;, data.id, data)
          this.parent._activeStream.set(data.id, {source: this, options: data})
        }
        this.parent.emit(&apos;receive&apos;, data.id)
        this.count++
      } else {
        if (data.type === &apos;full&apos;) {
          this.push(data.payload)
          this.count++
        } else if (data.type === &apos;end&apos;) {
          stack += data.payload
          this.push(new Uint8Array(JSON.parse(stack).data))
          this.count++
          stack = &apos;&apos;
        } else {
          stack += data.payload
        }
      }
    })
    this.source.on(&apos;end&apos;, () =&gt; {
      this.end()
    })
  }

  _read (size) {}
}

/**
 * Media Stream Manager
 * If using Video/audio stream for all users: use the broadcast primitive (Data Channel)
 * If using Video/audio stream for only one user, use the unicast primitive (Streaming)
 * But pay attention that using unicast method, when a shuffling occur the connection might diseapear.
 * For this usage, create an overlay network with only this peer connected to you.
 * Or shut down the shuffle mechanism but this is not recommended.
 * @extends CommunicationProtocol
 */
class Media extends CommunicationProtocol {
  constructor (source, protocol, options) {
    super(source, `foglet-media-internal-${protocol}`)
    this.options = {
      chunkSize: 16 * 1000 // pay attention to the maximum, or it will not work. see (http://viblast.com/blog/2015/2/5/webrtc-data-channel-message-size/)
    }
    this._activeMedia = new Map()
    this._activeStream = new Map()
    this._communication = new Communication(source, `foglet-media-internal-${protocol}`)

    this.NI = this._source.rps.NI
    this.NO = this._source.rps.NO

    this.i = this._source.rps.i
    this.o = this._source.rps.o
    this._source.rps.on(&apos;stream&apos;, (id, stream) =&gt; {
      this._receive(id, stream)
    })

    this._communication.onStreamBroadcast((id, stream) =&gt; {
      debug(&apos;Receive a media stream: &apos;, id, stream)
      this._reconstruct(stream)
    })
  }

  get pid () {
    return this._source.rps._pid()
  }

  /**
   * Send a message to only one neighbor...
   * @param {Object} id - The id to send the stream (media) to
   * @param  {Object}  media  - The stream to send
   * @return {boolean}
   */
  sendUnicast (id, media) {
    if (!media.id) media.id = uuid()
    if (!this._activeMedia.has(media.id)) {
      this._activeMedia.set(media.id, media)
      this._setListeners(media)
    }
    return this._source.rps.stream(id, media)
  }

  /**
   * Send a MediaStream using our broadcast primitives using Data Channel.
   * @param {Object}  media  - The stream to send
   * @param {Object} options - MediaRecorder options (see MediaRecorder API)
   * @return {boolean}
   */
  sendBroadcastOverDataChannel (media, options = {}) {
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder
    options = lmerge({
      mimeType: &apos;video/webm; codecs=&quot;vp8&quot;&apos;, // You MUST set the MIME type
      interval: 100, // A short interval is recommended to keep buffer sizes low
      bitsPerSecond: 128 * 1024
    }, options)

    if (!media.id) media.id = uuid()
    if (!this._activeMedia.has(media.id)) {
      this._activeMedia.set(media.id, media)
      this._setListeners(media)
    }
    console.log(media, options)
    let ms
    try {
      ms = new MediaRecorderStream(media, options)
    } catch (e) {
      throw new Error(&apos;Error when recording the media: &apos;, e)
    }
    const stream = this._communication.streamBroadcast()
    options.id = media.id
    stream.write(options)
    ms.on(&apos;data&apos;, (data) =&gt; {
      const chunkified = this.chunkify(JSON.stringify(data))
      if (chunkified.length === 0) {
        stream.write({
          type: &apos;full&apos;,
          id: 0,
          payload: chunkified[0]
        })
      } else {
        for (let i = 0; i &lt; chunkified.length; i++) {
          if (i === chunkified.length - 1) {
            stream.write({
              type: &apos;end&apos;,
              id: i,
              payload: chunkified[i]
            })
          } else {
            stream.write({
              type: &apos;chunk&apos;,
              id: i,
              payload: chunkified[i]
            })
          }
        }
      }
    })
    ms.on(&apos;end&apos;, () =&gt; {
      stream.end()
    })
  }

  _reconstruct (stream, options = null) {
    const readable = new ReadableFromStream(stream, this)
    readable.on(&apos;error&apos;, (err) =&gt; {
      console.error(err)
    })
  }

  getStreamMedia (id, elem) {
    if (!this._activeStream.has(id)) return undefined
    const wrapper = new MediaSource(elem)
    const writable = wrapper.createWriteStream(this._activeStream.get(id).options.mimeType)
    elem.addEventListener(&apos;error&apos;, function () {
      // listen for errors on the video/audio element directly
      var errorCode = elem.error
      var detailedError = wrapper.detailedError
      console.error(errorCode, detailedError)
      // wrapper.detailedError will often have a more detailed error message
    })

    writable.on(&apos;error&apos;, function (err) {
      // listening to the stream &apos;error&apos; event is optional
      console.error(err)
    })
    this._activeStream.get(id).source.pipe(writable)
  }

  /**
   * Handler executed when a message is recevied
   * @param  {string} id  - Message issuer&apos;s ID
   * @param  {Object} stream - The stream received
   * @return {void}
   */
  _receive (id, stream) {
    debug(&apos;Receive a media stream: &apos;, id, stream)
    if (!stream.id) stream.id = uuid()
    if (!this._activeMedia.has(stream.id)) {
      this._activeMedia.set(stream.id, {peer: id, stream})
      this._setListeners(stream)
    }
    this.emit(&apos;receive&apos;, id, stream)
  }

  _setListeners (media) {
    media.onactive = () =&gt; {
      console.log(&apos;Media %s is active...&apos;, media.id)
    }
    media.oninactive = () =&gt; {
      console.log(&apos;Media %s is inactive... (Disconnection or a Shuffling occured.)&apos;, media.id)
      // this._sendRequest(media.id)
    }
    media.onended = () =&gt; {
      console.log(&apos;Media %s is finished...&apos;, media.id)
    }
  }

  /**
   * Chunk a string into n message of size &apos;chunkSize&apos;
   * @param {string} string
   * @param {Number=this.options.chunkSize} chunkSize
   */
  chunkify (string, chunkSize = this.options.chunkSize) {
    // https://stackoverflow.com/questions/7033639/split-large-string-in-n-size-chunks-in-javascript
    return string.match(new RegExp(&apos;.{1,&apos; + chunkSize + &apos;}&apos;, &apos;g&apos;))
  }
}

module.exports = Media
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
